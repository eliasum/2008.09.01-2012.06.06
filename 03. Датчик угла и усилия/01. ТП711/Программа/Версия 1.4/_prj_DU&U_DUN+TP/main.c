/********************************************************************************/
/*                                                                              */
/*           Управляющая программа для датчика угла наклона и усилия            */
/*                        'ATMEGA168P' + 'ADIS16203'                            */
/*      Функциональная часть: тензопреобразователь + датчик угла наклона        */
/*                      Версия 1.4 (13 сентября 2011 г)                         */
/*                                                                              */
/********************************************************************************/
#include "main.h"
#include <math.h>
/*==============================================================================*/
/*                      Глобальные переменные программы.                        */
/*==============================================================================*/
// переменные усреднения:
unsigned int Buff[NSUM];                    // очередь замеров
unsigned char N_zamera;                     // номер замера
unsigned long sum;                          // 0..0x0ffffffff
unsigned char i;                            // 0..0x0ff

union u_int adc, weight, zero, one, sign;

union u_int angle, tick;
union u_sint angle_180, tick_180;
union u_sint temp, tock;

volatile unsigned char count_bod;           // счетчик БОД
volatile unsigned char t_led_on;            // 0.2 сек

unsigned char fl_set;                       // признак установки режима работы
/*==============================================================================*/
/*                                                                              */
/*                         Главная функция программы.                           */
/*                                                                              */
/*==============================================================================*/

int main(void)
{
  // задание интервала сброса WDT: 
  __watchdog_reset();                       // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
  WDTCSR |= (1<<WDCE) | (1<<WDE);           // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
  WDTCSR  = (1<<WDE)  | (1<<WDP3);          // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)
/*  
  Разряд DDxn регистра DDx определяет направление передачи данных
  через контакт ввода/вывода. Если этот разряд установлен в «1», то n-й вывод
  порта является выходом, если же сброшен в «0» — входом.
  Разряд PORTxn регистра PORTx выполняет двойную функцию. Если
  вывод функционирует как выход (DDxn = «1»), этот разряд определяет состояние 
  вывода порта. Если разряд установлен в «1», на выводе устанавливается 
  напряжение ВЫСОКОГО уровня. Если разряд сброшен в «0», на выводе 
  устанавливается напряжение НИЗКОГО уровня. Если же вывод функционирует как 
  вход (DDxn = «0»), разряд PORTxn определяет состояние внутреннего 
  подтягивающего резистора для данного вывода. При установке разряда PORTxn в «1»
  подтягивающий резистор подключается между выводом микроконтроллера 
  и проводом питания.
  Состояние вывода микроконтроллера (независимо от установок разряда DDxn) 
  может быть получено путем чтения разряда PINxn регистра PINx.
*/
  PORTB = (1<<LED)|(1<<RST)|(1<<CS)|(1<<MOSI)|(1<<MISO);
  DDRB  = (1<<LED)|(1<<RST)|(1<<CS)|(1<<MOSI)|(1<<SCK);
  
  PORTD = (1<<RXD)|(1<<TXD)|(1<<SET_)|(1<<S1)|(1<<S2)|(1<<S3);
  DDRD  = (1<<TXD)|(1<<TST)|(1<<DAC0);
 
  #define LED_ON       PORTB &= ~(1<<LED)
  #define LED_OFF      PORTB |=  (1<<LED)
  #define RST_ENABLE   PORTB &= ~(1<<RST)
  #define RST_DISABLE  PORTB |=  (1<<RST)
  #define CS_SET       PORTB |=  (1<<CS)
  #define CS_RES       PORTB &= ~(1<<CS)
  #define LED_TOGGLE   cpl(PORTB, LED)
  
  #define TST_ON       PORTD |=  (1<<TST)
  #define TST_OFF      PORTD &= ~(1<<TST)
  #define DAC0_ON      PORTD |=  (1<<DAC0)
  #define DAC0_OFF     PORTD &= ~(1<<DAC0)  
  
  // выбор режима работы датчика:
  if (PIND & (1<<SET_)) fl_set = 1; else fl_set = 0;

  TCCR0B = 0x00;                            // останов Т/С0
  TCNT0  = 0xB8;                            // нач. знач-е
  TCCR0A = 0x00;
  TCCR0B = 0x04;                            // таймер запускаем
  TIMSK0 = 0x01;                            // Т/С0 <- источник прерываний
  
  N_zamera  = 0;                            // начнем ... с "начала"
  count_bod = 1;                            // минимум 1 прерывание
  t_led_on  = 0;                            // время индикации
  
  __watchdog_reset();                       // 1-й "простой" cброс сторожевого таймера

  __enable_interrupt();                     // прерывания разрешаем

//////////////////////// Работа в режиме -= УСТАНОВКИ =- ///////////////////////
  if (!fl_set)
  {  
    // инициализация USART (9600):
    UCSR0B = 0x00;                          // запрет настроек USART0 на время установки скорости передачи
    UCSR0A = 0x00;                          
    UCSR0C = 0x06;                          // размер слова данных 8 бит
    UBRR0L = (unsigned char)UBBR_9K6;       // задание скорости 9600; пример в datasheet
    UBRR0H = (unsigned char)(UBBR_9K6>>8);
    UCSR0B = 0x08;                          // разрешение передачи (TXENn = 1)
    
    RST_ENABLE;                             // сброс ведомого импульсом длительностью 100 мкс
    delay_us(100);
    RST_DISABLE;   
    SPI_MasterInit();                       // инициализация SPI в режиме Master
         
    for (;;)
    {      
      while(count_bod);                     // ждать как
      count_bod = 1;                        // минимум 1 прерывание       
////////////////////////////////////////////////////////////////////////////////  
          
                             //ВЫВОД ВЕСА (AUX_DAC)
          
//////////////////////////////////////////////////////////////////////////////// 
      unsigned char byte;
      CS_RES;                               // активация ведомого
      
      DAC0_ON;                              // единичный полупериод меандра
      
      byte = AUX_ADC;                       // адрес регистра, вывод из которого при единичном полупериоде меандра   
      adc.du_c[1] = SPI_WriteRead(byte);    // старший байт данных из AUX_ADC при нулевом полупериоде меандра
      adc.du_c[1] &= 0x0F;                  // данные 12 бит
 
      byte = 0x0A;                          // любые данные
      adc.du_c[0] = SPI_WriteRead(byte);    // младший байт данных из AUX_ADC при нулевом полупериоде меандра
      zero.du_i = adc.du_i;
           
      delay_ms(149);                        // задержка для реализации меандра с периодом 300 мс
      delay_us(500);
        
      DAC0_OFF;                             // нулевой полупериод меандра
      
      byte = AUX_ADC;                       // адрес регистра, вывод из которого при нулевом полупериоде меандра     
      adc.du_c[1] = SPI_WriteRead(byte);    // старший байт данных из AUX_ADC при единичном полупериоде меандра
      adc.du_c[1] &= 0x0F;                  // данные 12 бит
 
      byte = 0x0A;                          // любые данные
      adc.du_c[0] = SPI_WriteRead(byte);    // младший байт данных из AUX_ADC при единичном полупериоде меандра
      one.du_i = adc.du_i;

      sign.du_i = one.du_i - zero.du_i;
      sign.du_i = moving_average(sign.du_i);// расчет "скользящего среднего"
      
      uart_puts("sign: ADC = ");            // вывод надписи sign: ADC = 
      uart_puti(sign.du_i);                 // вывод значения веса в тиках
      
      uart_putc(0x0d);                      // возврат каретки
      uart_putc(0x0a);                      // перевод на следующую строку
      
      delay_ms(124);                        // задержка для реализации меандра с периодом 300 мс
      delay_us(500);
           
      LED_TOGGLE;                           // светодиод меняет состояние на противоположное
      CS_SET;                               // деактивация ведомого

      __watchdog_reset();                   // "простой" cброс сторожевого таймера
      
    } // end of 'for (;;)' 
  } // end of 'if (!fl_set)' 
///////////////////////// Работа в режиме -= ДАТЧИК =- /////////////////////////
  else
  {    
    // инициализация USART (2400):
    UCSR0B = 0x00;                          // запрет настроек USART на время установки скорости передачи
    UCSR0A = 0x00;                          
    UCSR0C = 0x06;                          // размер слова данных 8 бит
    UBRR0L = UBBR_2K4L;                     // задание скорости 2400
    UBRR0H = UBBR_2K4H;   
    UCSR0B = 0x0C;                          // разрешение передачи (TXENn = 1); 9-Bit

    // инициализация Т/С0:
    TCCR0B = 0x00;                          // останов Т/С0
    TCNT0  = RELOAD_TIM0;                   // нач. знач-е
    TCCR0A = 0x00;
    TCCR0B = START_TIM0;                    // таймер запускаем
    TIMSK0 = 0x01;                          // Т/С0 <- источник прерываний
    
    RST_ENABLE;                             // сброс ведомого импульсом длительностью 100 мкс
    delay_us(100);
    RST_DISABLE;   
    SPI_MasterInit();                       // инициализация SPI в режиме Master
    
    __enable_interrupt();                   // прерывания разрешаем
    
    for (;;)
    {  
////////////////////////////////////////////////////////////////////////////////  
          
                    //Организация работы линии обмена K-LINE                    
          
////////////////////////////////////////////////////////////////////////////////   
      UCSR0B &= ~(1<<RXEN0);                // отключение приемника USART
      count_bod = CBOD;                     // счетчик БОД
      
      do
      {
        if (!(PIND & (1<<RXD))) count_bod = CBOD;
      } while (count_bod);                  // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
        
      UCSR0B |= (1<<RXEN0);                 // включение приемника USART

      while (!(UCSR0A & (1<<RXC0)));        // ждем завершение приема байта 

      if (UCSR0B & (1<<RXB80))              // если 9-й бит =1, то принята команда
      {
        unsigned char var;
        var  = UDR0;                        // UDRn - USART I/O Data Register n
        var &= 0x0f;                        // адрес датчика д/б не более 15
        if (var == NTP)                     // обратились к этому датчику?
        {    
          t_led_on  = T_LED_ON;             // время подсвечивания
          LED_ON;                           // LED-ON      
////////////////////////////////////////////////////////////////////////////////  
          
                             //ВЫВОД ВЕСА (AUX_DAC)
          
////////////////////////////////////////////////////////////////////////////////
          unsigned char byte;
          CS_RES;                           // активация ведомого
      
          DAC0_ON;                          // единичный полупериод меандра
      
          byte = AUX_ADC;                   // адрес регистра, вывод из которого при единичном полупериоде меандра   
          adc.du_c[1] = SPI_WriteRead(byte);// старший байт данных из AUX_ADC при нулевом полупериоде меандра
          adc.du_c[1] &= 0x0F;              // данные 12 бит
 
          byte = 0x0A;                      // любые данные
          adc.du_c[0] = SPI_WriteRead(byte);// младший байт данных из AUX_ADC при нулевом полупериоде меандра
          zero.du_i = adc.du_i;
           
          delay_ms(129);                    // задержка для реализации меандра с периодом 260 мс
          delay_us(500);
        
          DAC0_OFF;                         // нулевой полупериод меандра
      
          byte = AUX_ADC;                   // адрес регистра, вывод из которого при нулевом полупериоде меандра     
          adc.du_c[1] = SPI_WriteRead(byte);// старший байт данных из AUX_ADC при единичном полупериоде меандра
          adc.du_c[1] &= 0x0F;              // данные 12 бит
 
          byte = 0x0A;                      // любые данные
          adc.du_c[0] = SPI_WriteRead(byte);// младший байт данных из AUX_ADC при единичном полупериоде меандра
          one.du_i = adc.du_i;

          sign.du_i = one.du_i - zero.du_i;
          sign.du_i = moving_average(sign.du_i);// расчет "скользящего среднего"
      
          delay_ms(89);                     // задержка для реализации меандра с периодом 280 мс
          delay_us(500);
           
          CS_SET;                           // деактивация ведомого
          
          uart_putc(sign.du_c[1]);          // вывод на БЦК или SMON
          uart_putc(sign.du_c[0]);   
            
          __watchdog_reset();               // cброс сторожевого таймера
        } // end of 'if (var == NTP)' 
        if (var == NDUN)                    // обратились к этому датчику?
        {    
          get_sens();                       // вывод информации, поступающей от ADIS16203
          uart_putc(angle.du_c[1]);         // вывод угла на БЦК или SMON
          uart_putc(angle.du_c[0]);   
          
          __watchdog_reset();               // cброс сторожевого таймера
        } // end of 'if (var == NDUN)'
      } // end of 'if (UCSR0B & (1<<RXB80))'
    } // end of 'for (;;)' 
  } // end of 'else' 
} // end of 'main' 
/*==============================================================================*/
/*                                                                              */
/*                                Подпрограммы.                                 */
/*                                                                              */
/*==============================================================================*/

#pragma vector=TIMER0_OVF_vect
__interrupt void timer0_ovf_isr(void)
{
  //TIMER0 has overflowed
  TCNT0  = RELOAD_TIM0;                     // reload counter value

  if (count_bod)  count_bod--;

  if(t_led_on)  t_led_on--;                 // время подсвечивания --
  else          LED_OFF;                    // LED-OFF
}

// Подпрограмма инициализации SPI в режиме Master
void SPI_MasterInit(void)
{
/* 
  - Разрешение SPI в режиме мастера,
  - CPOL = 1 - генерируются тактовые импульсы отрицательной полярности,
  - CPHA = 1 - — обработка данных производится по заднему фронту импульсов сигнала SCK,
  - установка скорости обмена fck/128 
*/
  SPCR = (1<<SPE)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(1<<SPR1)|(1<<SPR0);
}

// Подпрограмма записи/чтения через SPI
unsigned char SPI_WriteRead(unsigned char dataout)
{
  // Запись байта в регист данных ведущего (инициализация передачи)
  SPDR = dataout;
  // Ожидание завершения передачи (пока бит SPIF не установлен)
  while(!(SPSR & (1<<SPIF)));
  // Чтение принятых данных и выход из процедуры
  return SPDR;
}

// Подпрограмма расчета "скользящего среднего"
unsigned int moving_average(unsigned int znachenie)
{
  Buff[N_zamera]=znachenie;                 // заносим новый замер в "очередь"
  // считаем среднее из "очереди":
  for (sum=0,i=0; i<NSUM; i++) sum += Buff[i];                           
  sum=sum>>KDEL; znachenie = (unsigned int)(0x0ffff & sum);
  N_zamera++; if (N_zamera == NSUM) N_zamera = 0;
  return znachenie;
}

// Подпрограмма реализации термостатирования
void termostat(signed int temperatura, unsigned char t0)                       
{
  if(temperatura <= t0)		                          
  TST_ON; 
  
  else
    {  
      if(temperatura > t0)	
      TST_OFF;  
    }
}

// Подпрограмма вывода информации, поступающей от ADIS16203 
void get_sens(void)
{
////////////////////////////////////////////////////////////////////////////////  
          
                          //ВЫВОД УГЛА 360° (INCL_OUT)
          
////////////////////////////////////////////////////////////////////////////////            
  unsigned char byte;

  t_led_on  = T_LED_ON;                     // время подсвечивания
  LED_ON;                                   // LED-ON
  CS_RES;                                   // активация ведомого
         
  byte = TEMP_OUT;                          // адрес регистра, вывод из которого в последующем цикле    
  SPI_WriteRead(byte);                      // запрос на чтение старшего байта регистра TEMP_OUT
  tick.du_c[1] = SPDR;                      // старший байт данных из INCL_OUT  
  tick.du_c[1] &= 0x3f;                     // данные 14 бит
      
  byte = 0x0C;                              // любые данные
  SPI_WriteRead(byte);                      // запрос на чтение младшего байта регистра TEMP_OUT
  tick.du_c[0] = SPDR;                      // младший байт данных из INCL_OUT 
          
  // преобразование тиков в значение угла наклона:
  angle.du_i = (unsigned int)(0.25*tick.du_i);   // 0.25 - значение угла целое с десятичной частью
/*          
  2 условия до и 2 условия после расчета "скользящего среднего" 
  необходимы для избавления от эффекта "перебора" всех значений угла 
  наклона от 0° до 359,9° при изменении угла от 0° до 359,9° и наоборот,
  которое связано с введением усреднения методом "скользящее среднее".
  Теперь датчик "думает" при изменении угла 134,9° до 135,0° и наоборот,
  т. е. вблизи рабочей зоны от 0° до 90° нет нежелательного эффекта.
*/
  if (angle.du_i < 1350)    
    angle.du_i = angle.du_i + 2250;
  else
  if ((angle.du_i <= 3599)&&(angle.du_i >= 1350)) 
    angle.du_i = angle.du_i - 1350;

  // расчет "скользящего среднего":
  angle.du_i = moving_average(angle.du_i);     
                
  if ((angle.du_i >= 2250)&&(angle.du_i < 3600))    
    angle.du_i = angle.du_i - 2250;
  else
  if (angle.du_i <= 2249)
    angle.du_i = angle.du_i + 1350;
////////////////////////////////////////////////////////////////////////////////  
          
                          //ВЫВОД ТЕМПЕРАТУРЫ (TEMP_OUT)
          
////////////////////////////////////////////////////////////////////////////////        
  byte = INCL_OUT;                          // адрес регистра, вывод из которого в последующем цикле      
  SPI_WriteRead(byte);                      // запрос на чтение старшего байта регистра INCL_OUT
  tock.du_sc[1] = SPDR;                     // старший байт данных из TEMP_OUT
  tock.du_sc[1] &= 0x0F;                    // данные 12 бит
 
  byte = 0x0A;                              // любые данные
  SPI_WriteRead(byte);                      // запрос на чтение младшего байта регистра INCL_OUT
  tock.du_sc[0] = SPDR;                     // младший байт данных из TEMP_OUT 
/*
  Учет знака числа. Сдвиг влево на 4 бита - "дополнение" числа до стандартного 
  формата 16 бит, в котором 16-й бит содержит информацию о знаке числа:
*/
  tock.du_si = tock.du_si << 4; 
/*
  Делением на 16 число "приводится обратно" к исходному 12-и битовому формату 
  с сохранением функции старшего бита числа как знакового:
*/
  tock.du_si /= 16;
           
  // преобразование тиков в значение температуры:
  float delta;
  if (tock.du_si >= 0x04FE)
    {
      delta = tock.du_si - 0x04FE;
      temp.du_si = (signed int)(25 - 0.47*delta);
    }  
  else
    {
      delta = 0x04FE - tock.du_si;
      temp.du_si = (signed int)(25 + 0.47*delta);
    }         
      
  termostat(temp.du_si, 50);                // температура статирования ~50°C
  CS_SET;                                   // деактивация ведомого
}