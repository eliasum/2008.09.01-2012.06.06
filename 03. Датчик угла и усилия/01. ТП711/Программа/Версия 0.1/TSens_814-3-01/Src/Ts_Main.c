/********************************************************************************/
/*                                                                              */
/*                     Управляющая программа для Тензо-датчика                  */
/*                          Версия 2.01 (2010.11.14)                            */
/*                                                                              */
/********************************************************************************/
#include "ts_main.h"
/*==============================================================================*/
/*                      Глобальные переменные программы.                        */
/*==============================================================================*/
  bit fl_sign;                  // знак коррекции (1 - отнимать)
  bit fl_swca;                  // переключатель "коррекция" / "оцифровка"
  bit fl_cmd;                   // чужая комманда/данные
  bit fl_dev;                   // обращение к основному каналу АЦП
  bit fl_ad;                    // событие - конец АЦ преобразования
  union u_int VAR;              // врем. хран-е данных
  union u_int ADC;              // данные 'ADC'
  unsigned int data Badc[NSUM]; // буфер усреднения
  unsigned int AIN0_DAT;        // данные "основного" канала АЦП
  unsigned int CORR;            // значение коррекции

  unsigned char byte_ndv;       // "номера устройства" - определяется перемычкой
  unsigned char COUNT_BOD;      // счетчик БОД

  unsigned char rcom;           // принчтая "команда"
/*==============================================================================*/
/*                                                                              */
/*                         Главная функция программы.                           */
/*                                                                              */
/*==============================================================================*/
void main(void)
{
/*==============================================================================*/
/*                      Переменные главной  функции.                            */
/*==============================================================================*/
  /*----------------------------------------------------------------------------*/
  /*                     Инициализируем аппаратуру.                             */
  /*----------------------------------------------------------------------------*/

// Синтезатор рабочей частоты ядра:

  PLLCON = 0x001;                       // 8388608 герц


// Сторожевой таймер:

  WDWR = 1;                             // разрешение записи в 'WDCON'
  WDCON = 0x072;                        // enable WDT for 2.0s timeout

// Прерывания:  

  IE = 0x00;                            // запр. все прер-я
  IP = 0x00;                            // приоритетность

/*           SERIAL PORT
             -----------  
- 9 битовый УАПП (реж.3; скор-ть опр. Ftc1)
- SCON.SM2=1 => бит RI не активизируется,
  если 9-й бит принимаемых данных =0
- SCON.REN=1 => прием посл.данных разреш. */

  SCON = 0x0f0;

// Установка таймеров:

  TCON = 0x00;                          // управл. TIM 1&0
  TMOD = 0x21;                          // режимы "2/1"
  TH1 = CONST_BAUD_RATE;                // F(UART)
  TH0 = CLSTH;                          // F(Тик)
  TL0 = CLSTL;
  RCAP2H = CLATH;                       // F(T(ADC))
  RCAP2L = CLATL;


// Конфигурация АЦП:

  ADCCON1 = 0x09e;                      // power up ADC & enable Timer2 mode
//  ADCCON2 = CHAN;                     // выбор канала для АЦП

// Конфигурация ЦАП
  DACCON = 0x01f;                       // both DACs on,12bit,asynchronous
  DAC1H = UDAC1H;
  DAC1L = UDAC1L;

  byte_ndv = P3;                        // фиксация перемычки "номер устройства"
  byte_ndv >>= 2;                       // 0001 1100
  byte_ndv &= 0x07;                     // 0000 0111
  byte_ndv += NDEV;                     // + база

// Запуск ...

  TR0 = 1;                              // запуск TIM0
  TR1 = 1;                              // запуск TIM1
  REN = 0;                              // прием по 'RxD' 'OFF'
  EA = 1;                               // разр.прер.  "ВСЁ"

  Adc_ini();

   /*----------------------------------------------------------------------------*/
   /*                 Основной цикл программы.                                   */
   /*----------------------------------------------------------------------------*/

  for(;;)
  {
    DIR = 0;    
    COUNT_BOD = CBOD;                   // счетчик БОД
    ET0 = 1;                            // пр-я по 'T0' 'ON'

    do {
         if (!RXD) COUNT_BOD = CBOD;
    } while (COUNT_BOD);                // ожидание СИНХРО-ПАУЗЫ

    ET0 = 0;                            // пр-я по 'T0' 'OFF'
    RI = 0;                             // очистка флага приема по 'RxD'
    VAR.du_c[0] = SBUF;                 // очистка буфера приема
    REN = 1;                            // прием по 'RxD' 'ON'


    while(!RI);
    REN = 0;                            // прием по 'RxD' 'OFF'
    fl_cmd = fl_cmd = 0;

    if(RB8)
    {
      RB8 = 0;
      fl_cmd = 1;                                    // это "чужой" CMD !
      rcom = 0x0f & SBUF;
      if(rcom == byte_ndv)
        {fl_dev = 1; fl_cmd = 0; REQ_ME = ON_PIN;}   // это "свой"  CMD !
    }

    if(fl_cmd) Refr();
    if(fl_dev) Out_data(AIN0);
    REQ_ME = OFF_PIN;                               // выключим индикацию обращения   
  }
}


/*------------------------------------------------------------------------------*/
/* Функция:    Выводит в UART запрвшиваемый кенал АЦП                           */
/* Принимает:  N канала АЦП (0...8)                                             */
/* Возвращает: ничего                                                           */
/*------------------------------------------------------------------------------*/
void Out_data (unsigned char chnl) {
  union u_int o_dat;
  DIR = 1;
  if(fl_dev) o_dat.du_i = AIN0_DAT;
  TB8 = 0; SBUF = o_dat.du_c[0]; while (!TI); TI = 0; // старший байт
  TB8 = 0; SBUF = o_dat.du_c[1]; while (!TI); TI = 0; // младший байт
  Adc_sw(chnl);
  if(fl_dev) Add_sum ();
  fl_dev = 0;
}

/*------------------------------------------------------------------------------*/
/* Функция:    Усредняет данные АЦП за последние NSUM выборок                   */
/* Принимает:  ничего                                                           */
/* Возвращает: ничего                                                           */
/*------------------------------------------------------------------------------*/
void Add_sum (void) {
  unsigned char count;
  if(!fl_swca)  // если была коррекция - пропустим !
  {
    for (count = 0; count < (NSUM - 1); count++)
      Badc[count] = Badc[count + 1];
    Badc[NSUM-1] = ADC.du_i;
    AIN0_DAT = 0;
    for (count = 0; count < NSUM; count++)
      AIN0_DAT += Badc[count];
    AIN0_DAT = 0x0fff - (AIN0_DAT / NSUM);      // инвертирование
  }
}

/*------------------------------------------------------------------------------*/
/* Функция:    Обновляет среднее значение АЦП "основного" канала                */
/* Принимает:  ничего                                                           */
/* Возвращает: ничего                                                           */
/*------------------------------------------------------------------------------*/
void Refr(void) {
  Adc_sw(AIN0);
  Add_sum();
  fl_cmd = 0;
}

/*------------------------------------------------------------------------------*/
/* Функция:    Инициализация буфера усреднения                                  */
/* Принимает:  ничего                                                           */
/* Возвращает: ничего                                                           */
/*------------------------------------------------------------------------------*/
void Adc_ini(void) {
  unsigned char count;
  DAC0H = 0x00;
  DAC0L = 0x00;
  fl_swca = 0;          // сначало коррекция !
  for (count = 1; count < NSUM; count++)
  {
    Adc_sw(AIN0);       // коррекция
    Adc_sw(AIN0);       // данные
    Badc[count] = ADC.du_i;
  }
  Add_sum();
}

/*------------------------------------------------------------------------------*/
/* Функция:    Переключатель оцифровка / коррекция                              */
/* Принимает:  номер канала АЦП                                                 */
/* Возвращает: ничего                                                           */
/*------------------------------------------------------------------------------*/
void Adc_sw (unsigned char chanell) {

  Go_adc(chanell);
  if (chanell == AIN0)
  {
    if(!fl_swca)
    {
      DAC0H = UDAC0H;   // приняли коррекцию
      DAC0L = UDAC0L;
      fl_swca = 1;      // потом будут данные
      if(ADC.du_i > UDAC1)
      {
        CORR = ADC.du_i - UDAC1;
        fl_sign = 1;    // коррекцию отнимать !
      }
      else
      {
        CORR = UDAC1 - ADC.du_i;
        fl_sign = 0;    // коррекцию прибавлять !      
      }
    }
    else
    {
      DAC0H = 0;        // приняли данные
      DAC0L = 0;
      fl_swca = 0;      // потом будeт коррекция
      if(fl_sign) ADC.du_i -= CORR;
      else        ADC.du_i += CORR;
    }
  }
}

/*------------------------------------------------------------------------------*/
/* Функция:    Производит АЦП выбранного канала (0...8)                         */
/* Принимает:  номер канала АЦП                                                 */
/* Возвращает: значение в глобальной переменной ADC                             */
/*------------------------------------------------------------------------------*/
void Go_adc (unsigned char chanell) {
  union u_lng sum;
  unsigned char count = 0;

  ADCCON2 = chanell;            // канал АЦП
  sum.du_l = 0;                 // сумма отсчетов (256)
  TL2 = CLATL;                  // 6400 Гц
  TH2 = CLATH;                  // одинаковый старт
  fl_ad = 1;
  EADC = 1;                     // разр.пр-я по 'ADC'
  TR2 = 1;                      // run Timer2
  do {
       while(fl_ad);
       sum.du_l += VAR.du_i;
       count++;
       fl_ad = 1;
     } while (count != 0);
  EADC = 0;
  TR2 = 0;
  ADC.du_c[0] = sum.du_c[1];   // результат =
  ADC.du_c[1] = sum.du_c[2];   // сумма отсчетов / 256
  RWDT;
}

// Вектор прер-ния 000BH, банк регистров 1
    
static void timer0 (void) interrupt 1 using 1
{
  TH0 = CLSTH; TL0 = CLSTL;
  if(COUNT_BOD) COUNT_BOD--;
}

// Вектор прер-ния 0033H, банк регистров 1
    
static void end_adc (void) interrupt 6 using 1
{
  VAR.du_c[0] = ADCDATAH & 0x0f;
  VAR.du_c[1] = ADCDATAL;
  fl_ad = 0;
}

