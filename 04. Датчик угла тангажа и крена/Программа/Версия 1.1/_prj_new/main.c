/********************************************************************************/
/*                                                                              */
/*             Управляющая программа для 'ATMEGA168P' + 'ADIS16209'             */
/*                        Версия 1.1 (10 февраля 2012 г)                        */
/*                                                                              */
/********************************************************************************/
#include "main.h"
#include <math.h>
/*==============================================================================*/
/*                                                                              */
/*                         Главная функция программы.                           */
/*                                                                              */
/*==============================================================================*/
int main(void)
{
  // задание интервала сброса WDT: 
  __watchdog_reset();                          // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
  WDTCSR |= (1<<WDCE) | (1<<WDE);              // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
  WDTCSR  = (1<<WDE)  | (1<<WDP3);             // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)

  PORTB = (1<<LED)|(1<<CS)|(1<<MOSI)|(1<<MISO)|(1<<SCK);
  DDRB  = (1<<LED)|(1<<CS)|(1<<MOSI)|(1<<SCK);

  PORTD = (1<<RXD)|(1<<TXD)|(1<<RST)|(1<<SET_);
  DDRD  = (1<<TXD)|(1<<RST)|(1<<TST)|(1<<RST);
  
  // выбор режима работы датчика:
  if (PIND & (1<<SET_)) fl_set = 1; else fl_set = 0;
  
  N_zamera  = 0;                               // начнем ... с "начала"
  count_bod = 1;                               // минимум 1 прерывание
  t_led_on  = 0;                               // время индикации
  
  __watchdog_reset();                          // 1-й "простой" cброс сторожевого таймера

  __enable_interrupt();                        // прерывания разрешаем

//////////////////////// Работа в режиме -= УСТАНОВКИ =- ///////////////////////
  if (!fl_set)
  {
    // инициализация USART (9600):
    UCSR0B = 0x00;                             // запрет настроек USART0 на время установки скорости передачи
    UCSR0A = 0x00;                          
    UCSR0C = 0x06;                             // размер слова данных 8 бит
    UBRR0L = (unsigned char)UBBR_9K6;          // задание скорости 9600; пример в datasheet
    UBRR0H = (unsigned char)(UBBR_9K6>>8);
    UCSR0B = 0x08;                             // разрешение передачи (TXENn = 1)
    
    // инициализация Т/С0:
    TCCR0B = 0x00;                             // останов Т/С0
    TCNT0  = RELOAD_TIM0;                      // нач. знач-е
    TCCR0A = 0x00;
    TCCR0B = START_TIM0;                       // таймер запускаем
    TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
    
    RST_ENABLE;                            
    delay_ms(1);                               // сброс ведомого импульсом длительностью 1 мс
    RST_DISABLE;   
    delay_ms(250);                             // время, необходимое для установления напряжения питания
    
    SPI_MasterInit();                          // инициализация SPI в режиме Master
    
    // вывод строки из ПЗУ, uart_putc(0x0a); - перевод на след. строку  
    uart_puts_p(Title);                                 uart_putc(0x0d); uart_putc(0x0a);                        
    uart_puts("------------------------------------");  uart_putc(0x0d); uart_putc(0x0a);  
/*     
    smpl_time();                               // управление периодом выборок
    smpl_time();     
    
    avg_cnt();                                 // управление фильтрацией
    avg_cnt();
*/    
    for (;;)
    {      
      while(count_bod);                        // ждать как
      count_bod = 1;                           // минимум 1 прерывание 
      
      unsigned char byte;
////////////////////////////////////////////////////////////////////////////////  
          
                        //ВЫВОД УГЛА X = ±90° (XINCL_OUT)
          
////////////////////////////////////////////////////////////////////////////////  
      CS_RES;                                  // активация ведомого
      
      byte = YINCL_OUT;                        // адрес регистра, прием данных из которого в следующем цикле    
      tick_x.du_sc[1] = SPI_WriteRead(byte);   // старший байт данных XINCL_OUT
      tick_x.du_sc[1] &= 0x3f;                 // данные 14 бит
      
      byte = 0x0F;                             // любые данные
      tick_x.du_sc[0] = SPI_WriteRead(byte);   // младший байт данных XINCL_OUT 
/*
      Учет знака числа. Сдвиг влево на два бита - "дополнение" числа до стандартного 
      формата 16 бит, в котором 16-й бит содержит информацию о знаке числа:
*/
      tick_x.du_si = tick_x.du_si << 2; 
/*
      Делением на 4 число "приводится обратно" к исходному 14-и битовому формату 
      с сохранением функции старшего бита числа как знакового:
*/ 
      tick_x.du_si /= 4;   
      
      uart_puts("Tick_x/Angle_x = 0x");        // вывод надписи Tick_x/Angle_x = 0x
      uart_puthex_byte(tick_x.du_sc[1]);       // вывод старшего байта данных XINCL_OUT
      uart_puthex_byte(tick_x.du_sc[0]);       // вывод младшего байта данных XINCL_OUT
      uart_puts("/");                          // вывод знака / 

      // преобразование тиков в значение угола наклона:
      angle_x.du_si = (unsigned int)(0.25*tick_x.du_si);
      
      // расчет "скользящего среднего":
      //angle_x.du_si = moving_average(angle_x.du_si);  
      
      uart_puti(angle_x.du_si);                // вывод значения угла наклона с десятичным значением без запятой
      uart_puts("`; ");                        // вывод знаков `;  
      uart_putc(0x0d);                         // возврат каретки
      uart_putc(0x0a);                         // перевод на следующую строку 
              
      CS_SET;                                  // деактивация ведомого
      delay_us(5);
////////////////////////////////////////////////////////////////////////////////  
          
                        //ВЫВОД УГЛА Y = ±90° (YINCL_OUT)
          
////////////////////////////////////////////////////////////////////////////////       
      CS_RES;                                  // активация ведомого
      
      byte = TEMP_OUT;                         // адрес регистра, прием данных из которого в следующем цикле
      tick_y.du_sc[1] = SPI_WriteRead(byte);   // старший байт данных YINCL_OUT  
      tick_y.du_sc[1] &= 0x3F;                 // данные 14 бит
      
      byte = 0x0B;                             // любые данные
      tick_y.du_sc[0] = SPI_WriteRead(byte);   // младший байт данных YINCL_OUT 
/*
      Учет знака числа. Сдвиг влево на два бита - "дополнение" числа до стандартного 
      формата 16 бит, в котором 16-й бит содержит информацию о знаке числа:
*/
      tick_y.du_si = tick_y.du_si << 2; 
/*
      Делением на 4 число "приводится обратно" к исходному 14-и битовому формату 
      с сохранением функции старшего бита числа как знакового:
*/ 
      tick_y.du_si /= 4; 
      
      uart_puts("Tick_y/Angle_y = 0x");        // вывод надписи Tick_y/Angle_y = 0x
      uart_puthex_byte(tick_y.du_sc[1]);       // вывод старшего байта данных YINCL_OUT
      uart_puthex_byte(tick_y.du_sc[0]);       // вывод младшего байта данных YINCL_OUT
      uart_puts("/");                          // вывод знака / 
      
      // преобразование тиков в значение угола наклона:
      angle_y.du_si = (signed int)(0.25*tick_y.du_si);   
      
      // расчет "скользящего среднего":
      //angle_y.du_si = moving_average(angle_y.du_si);
      
      uart_puti(angle_y.du_si);                // вывод значения угла наклона с десятичным значением без запятой  
      uart_puts("`; ");                        // вывод знаков `;   
      uart_putc(0x0d);                         // возврат каретки
      uart_putc(0x0a);                         // перевод на следующую строку 
      
      CS_SET;                                  // деактивация ведомого
      delay_us(5);
////////////////////////////////////////////////////////////////////////////////  
          
                          //ВЫВОД ТЕМПЕРАТУРЫ (TEMP_OUT)
          
////////////////////////////////////////////////////////////////////////////////     
      CS_RES;                                  // активация ведомого
      
      byte = XINCL_OUT;                        // адрес регистра, прием данных из которого в следующем цикле   
      tock.du_sc[1] = SPI_WriteRead(byte);     // старший байт данных TEMP_OUT
      tock.du_sc[1] &= 0x0F;                   // данные 12 бит
 
      byte = 0x0D;                             // любые данные
      tock.du_sc[0] = SPI_WriteRead(byte);     // младший байт данных TEMP_OUT 
/*
      Учет знака числа. Сдвиг влево на 4 бита - "дополнение" числа до стандартного 
      формата 16 бит, в котором 16-й бит содержит информацию о знаке числа:
*/
      tock.du_si = tock.du_si << 4; 
/*
      Делением на 16 число "приводится обратно" к исходному 12-и битовому формату 
      с сохранением функции старшего бита числа как знакового:
*/
      tock.du_si /= 16;
      
      uart_puts("Tock/Temperature = 0x");      // вывод надписи Tock/Temperature = 0x
      uart_puthex_byte(tock.du_sc[1]);         // вывод старшего байта данных TEMP_OUT
      uart_puthex_byte(tock.du_sc[0]);         // вывод младшего байта данных TEMP_OUT
      uart_puts("/");                          // вывод знака / 
      
      // преобразование тиков в значение температуры:
      float delta;
      if (tock.du_si >= 0x04FE)
      {
        delta = tock.du_si - 0x04FE;
        temp.du_si = (signed int)(25 - 0.47*delta);
      }  
      else
      {
        delta = 0x04FE - tock.du_si;
        temp.du_si = (signed int)(25 + 0.47*delta);
      }         
            
      uart_puti(temp.du_si);                   // вывод значения температуры
      uart_puts("`C");                         // вывод знаков `C
      
      uart_putc(0x0d);                         // возврат каретки
      uart_putc(0x0a);                         // перевод на следующую строку 
      delay_ms(250);                           // задержка для усреднения показаний
           
//    termostat(temp.du_si, 50);               // температура статирования ~50°C
      
      LED_TOGGLE;                              // светодиод меняет состояние на противоположное
      
      CS_SET;                                  // деактивация ведомого

      __watchdog_reset();                      // "простой" cброс сторожевого таймера
      
    } // end of 'for (;;)' 
  } // end of 'if (!fl_set)' 
///////////////////////// Работа в режиме -= ДАТЧИК =- /////////////////////////
  else
  {
    // инициализация USART (2400):
    UCSR0B = 0x00;                             // запрет настроек USART на время установки скорости передачи
    UCSR0A = 0x00;                             
    UCSR0C = 0x06;                             // размер слова данных 8 бит
    UBRR0L = UBBR_2K4L;                        // задание скорости 2400
    UBRR0H = UBBR_2K4H;   
    UCSR0B = 0x0C;                             // разрешение передачи (TXENn = 1); 9-Bit

    // инициализация Т/С0:
    TCCR0B = 0x00;                             // останов Т/С0
    TCNT0  = RELOAD_TIM0;                      // нач. знач-е
    TCCR0A = 0x00;
    TCCR0B = START_TIM0;                       // таймер запускаем
    TIMSK0 = 0x01;                             // Т/С0 <- источник прерываний
    
    RST_ENABLE;                            
    delay_ms(1);                               // сброс ведомого импульсом длительностью 1 мс
    RST_DISABLE;   
    delay_ms(250);                             // время, необходимое для установления напряжения питания
    
    SPI_MasterInit();                          // инициализация SPI в режиме Master
    
    __enable_interrupt();                      // прерывания разрешаем
////////////////////////////////////////////////////////////////////////////////  
          
                    //Организация работы линии обмена K-LINE                    
          
////////////////////////////////////////////////////////////////////////////////  
/*    
    smpl_time();                               // управление периодом выборок
    smpl_time();     
    
    avg_cnt();                                 // управление фильтрацией
    avg_cnt();
*/    
    for (;;)
    {  
      UCSR0B &= ~(1<<RXEN0);                   // отключение приемника USART
      count_bod = CBOD;                        // счетчик БОД

      do
      {
        if (!(PIND & (1<<RXD))) count_bod = CBOD;
      } while (count_bod);                     // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)
        
      UCSR0B |= (1<<RXEN0);                    // включение приемника USART

      while (!(UCSR0A & (1<<RXC0)));           // ждем завершение приема байта 

      if (UCSR0B & (1<<RXB80))                 // если 9-й бит =1, то принята команда
      {
        unsigned char var;
        var  = UDR0;                           // UDRn - USART I/O Data Register n
        var &= 0x0f;                           // адрес датчика д/б не более 15
        if (var == PITCH)                      // обратились к этому датчику?
        {    
////////////////////////////////////////////////////////////////////////////////  
          
                        //ВЫВОД УГЛА X = ±90° (XINCL_OUT)
          
////////////////////////////////////////////////////////////////////////////////  
         unsigned char byte;
         
         t_led_on  = T_LED_ON;                 // время подсвечивания
         LED_ON;                               // LED-ON
         
         CS_RES;                               // активация ведомого
      
         byte = XINCL_OUT;                     // адрес регистра, прием данных из которого в следующем цикле    
         tick_x.du_sc[1] = SPI_WriteRead(byte);// старший байт данных XINCL_OUT
         tick_x.du_sc[1] &= 0x3f;              // данные 14 бит
      
         byte = 0x0F;                          // любые данные
         tick_x.du_sc[0] = SPI_WriteRead(byte);// младший байт данных XINCL_OUT 
/*
         Учет знака числа. Сдвиг влево на два бита - "дополнение" числа до стандартного 
         формата 16 бит, в котором 16-й бит содержит информацию о знаке числа:
*/
         tick_x.du_si = tick_x.du_si << 2; 
/*
         Делением на 4 число "приводится обратно" к исходному 14-и битовому формату 
         с сохранением функции старшего бита числа как знакового:
*/ 
         tick_x.du_si /= 4;   
      
         // преобразование тиков в значение угола наклона:
         angle_x.du_si = (unsigned int)(0.25*tick_x.du_si);
              
         CS_SET;                               // деактивация ведомого
         
         uart_putc(angle_x.du_sc[1]);          // вывод угла по оси x на БЦК или SMON
         uart_putc(angle_x.du_sc[0]);
        }
        
         if (var == ROLL)                      // обратились к этому датчику?
        {
////////////////////////////////////////////////////////////////////////////////  
          
                        //ВЫВОД УГЛА Y = ±90° (YINCL_OUT)
          
////////////////////////////////////////////////////////////////////////////////
         unsigned char byte;
         
         t_led_on  = T_LED_ON;                 // время подсвечивания
         LED_ON;                               // LED-ON
  
         CS_RES;                               // активация ведомого
      
         byte = YINCL_OUT;                     // адрес регистра, прием данных из которого в следующем цикле
         tick_y.du_sc[1] = SPI_WriteRead(byte);// старший байт данных YINCL_OUT  
         tick_y.du_sc[1] &= 0x3F;              // данные 14 бит
      
         byte = 0x0B;                          // любые данные
         tick_y.du_sc[0] = SPI_WriteRead(byte);// младший байт данных YINCL_OUT 
/*
         Учет знака числа. Сдвиг влево на два бита - "дополнение" числа до стандартного 
         формата 16 бит, в котором 16-й бит содержит информацию о знаке числа:
*/
         tick_y.du_si = tick_y.du_si << 2; 
/*
         Делением на 4 число "приводится обратно" к исходному 14-и битовому формату 
         с сохранением функции старшего бита числа как знакового:
*/ 
         tick_y.du_si /= 4; 
               
         // преобразование тиков в значение угола наклона:
         angle_y.du_si = (signed int)(0.25*tick_y.du_si);     
      
         CS_SET;                               // деактивация ведомого  
          
         uart_putc(angle_y.du_sc[1]);          // вывод угла по оси y на БЦК или SMON
         uart_putc(angle_y.du_sc[0]);
        }  
         __watchdog_reset();                   // cброс сторожевого таймера
      } // end of 'if (UCSR0B & (1<<RXB80))'
    } // end of 'for (;;)' 
  } // end of 'else' 
} // end of 'main' 
/*==============================================================================*/
/*                                                                              */
/*                                Подпрограммы.                                 */
/*                                                                              */
/*==============================================================================*/
#pragma vector=TIMER0_OVF_vect
__interrupt void timer0_ovf_isr(void)
{
  //TIMER0 has overflowed
  TCNT0  = RELOAD_TIM0;                        // reload counter value

  if (count_bod)  count_bod--;

  if(t_led_on)  t_led_on--;                    // время подсвечивания --
  else          LED_OFF;                       // LED-OFF
}

// Подпрограмма инициализации SPI в режиме Master
void SPI_MasterInit(void)
{
/* 
  - Разрешение SPI в режиме мастера,
  - CPOL = 1 - генерируются тактовые импульсы отрицательной полярности,
  - CPHA = 1 - — обработка данных производится по заднему фронту импульсов сигнала SCK,
  - установка скорости обмена fck/128 
*/
  SPCR = (1<<SPE)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(1<<SPR1)|(1<<SPR0);
}

// Подпрограмма записи/чтения через SPI
unsigned char SPI_WriteRead(unsigned char dataout)
{
  // Запись байта в регист данных ведущего (инициализация передачи)
  SPDR = dataout;
  // Ожидание завершения передачи (пока бит SPIF не установлен)
  while(!(SPSR & (1<<SPIF)));
  // Чтение принятых данных и выход из процедуры
  return SPDR;
}

// Подпрограмма расчета "скользящего среднего"
unsigned int moving_average(unsigned int znachenie)
{
  Buff[N_zamera]=znachenie;                    // заносим новый замер в "очередь"
  // считаем среднее из "очереди":
  for (sum=0,i=0; i<NSUM; i++) sum += Buff[i];                           
  sum=sum>>KDEL; znachenie = (unsigned int)(0x0ffff & sum);
  N_zamera++; if (N_zamera == NSUM) N_zamera = 0;
  return znachenie;
}

// Подпрограмма реализации термостатирования
void termostat(signed int temperatura, unsigned char t0)                       
{
  if(temperatura <= t0)		                          
  TST_ON; 
  
  else
    {  
      if(temperatura > t0)	
      TST_OFF;  
    }
}
