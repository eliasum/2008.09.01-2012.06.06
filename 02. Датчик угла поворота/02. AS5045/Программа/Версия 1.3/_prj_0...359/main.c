/********************************************************************************/
/*                                                                              */
/*              Управляющая программа для 'ATMEGA168P' + 'AS5045'               */
/*                      Версия 1.3 (15 августа 2011 г)                          */
/*                                                                              */
/********************************************************************************/
#include "main.h"
#include <math.h>
/*==============================================================================*/
/*                      Глобальные переменные программы.                        */
/*==============================================================================*/
union u_lng tick, tock, angle, valid, range;

volatile unsigned char count_bod;           // счетчик БОД
volatile unsigned char t_led_on;            // 0.2 сек

unsigned char fl_set;                       // признак установки режима работы
unsigned char const __flash Title[] = "AS5045 - convertion of Ticks to Angle";
/*==============================================================================*/
/*                                                                              */
/*                         Главная функция программы.                           */
/*                                                                              */
/*==============================================================================*/

int main(void)
{
  // задание интервала сброса WDT: 
  __watchdog_reset();                       // WDTCSR = WDIF WDIE WDP3 WDCE WDE WDP2 WDP1 WDP0 (XXXX XXXX)
  WDTCSR |= (1<<WDCE) | (1<<WDE);           // разрешение настройки/системного сброса WDT      (XXX1 1XXX)
  WDTCSR  = (1<<WDE)  | (1<<WDP3);          // установка тайм-аута = 512K циклов (~ 4.0 с)     (0010 1000)
/*  
  Разряд DDxn регистра DDx определяет направление передачи данных
через контакт ввода/вывода. Если этот разряд установлен в «1», то n-й вывод
порта является выходом, если же сброшен в «0» — входом.
  Разряд PORTxn регистра PORTx выполняет двойную функцию. Если
вывод функционирует как выход (DDxn = «1»), этот разряд определяет состояние 
вывода порта. Если разряд установлен в «1», на выводе устанавливается 
напряжение ВЫСОКОГО уровня. Если разряд сброшен в «0», на выводе 
устанавливается напряжение НИЗКОГО уровня. Если же вывод функционирует как 
вход (DDxn = «0»), разряд PORTxn определяет состояние внутреннего 
подтягивающего резистора для данного вывода. При установке разряда PORTxn в «1»
подтягивающий резистор подключается между выводом микроконтроллера 
и проводом питания.
  Состояние вывода микроконтроллера (независимо от установок разряда DDxn) 
 может быть получено путем чтения разряда PINxn регистра PINx.
*/
  PORTB = (1<<LED)|(1<<CS)|(1<<MOSI)|(1<<MISO);
  DDRB  = (1<<LED)|(1<<CS)|(1<<MOSI)|(1<<SCK);
  
  PORTD = (1<<RXD)|(1<<TXD)|(1<<RE)|(1<<SET_);
  DDRD  = (1<<TXD)|(1<<RE);
    
  #define LED_ON       PORTB &= ~(1<<LED)
  #define LED_OFF      PORTB |=  (1<<LED)
  #define CS_SET       PORTB |=  (1<<CS)
  #define CS_RES       PORTB &= ~(1<<CS)
  #define LED_TOGGLE   cpl(PORTB, LED)
  
  // выбор режима работы датчика:
  if (PIND & (1<<SET_)) fl_set = 1; else fl_set = 0;

  TCCR0B = 0x00;                            // останов Т/С0
  TCNT0  = 0xB8;                            // нач. знач-е
  TCCR0A = 0x00;
  TCCR0B = 0x04;                            // таймер запускаем
  TIMSK0 = 0x01;                            // Т/С0 <- источник прерываний
  
  count_bod = 1;                            // минимум 1 прерывание
  t_led_on  = 0;                            // время индикации
  
  __watchdog_reset();                       // 1-й "простой" cброс сторожевого таймера

  __enable_interrupt();                     // прерывания разрешаем

//////////////////////// Работа в режиме -= УСТАНОВКИ =- ///////////////////////
  if (fl_set)
  {
    // инициализация USART (9600):
    UCSR0B = 0x00;                          // запрет настроек USART0 на время установки скорости передачи
    UCSR0A = 0x00;                          
    UCSR0C = 0x06;                          // размер слова данных 8 бит
    UBRR0L = (unsigned char)UBBR_9K6;       // задание скорости 9600; пример в datasheet
    UBRR0H = (unsigned char)(UBBR_9K6>>8);
    UCSR0B = 0x08;                          // разрешение передачи (TXENn = 1)
       
    SPI_MasterInit();                       // инициализация SPI в режиме Master
    
    // вывод строки из ПЗУ, uart_putc(0x0a); - перевод на след. строку  
    uart_puts_p(Title);                                 uart_putc(0x0d); uart_putc(0x0a);                        
    uart_puts("------------------------------------");  uart_putc(0x0d); uart_putc(0x0a);  
     
    for (;;)
    {            
      while(count_bod);                     // ждать как
      count_bod = 1;                        // минимум 1 прерывание 
      
      CS_RES;                               // активация ведомого, инициализация чтения данных 

      SPI_WriteRead(0);                     // чтение старших 8 бит данных от AS5045
      tick.du_c[2] = SPDR;                  // байт данных от AS5045 --> 'dddd dddd'
      
      SPI_WriteRead(0);                     // чтение следующих 8 бит данных от AS5045
      tick.du_c[1] = SPDR;                  // байт данных от AS5045 --> 'dddd oclm'
      
      SPI_WriteRead(0);                     // чтение следующих 8 бит данных от AS5045
      tick.du_c[0] = SPDR;                  // байт данных от AS5045 --> 'mp-- ----'
/*      
      Делением на 4096 = 2^12 число 'dddd dddd dddd oclm mp-- ----' 
      приводится к 12-и битовому формату '0000 0000 0000 dddd dddd dddd', 
      которое содержит только угловые данные:
*/      
      tock.du_l = tick.du_l/2048;           // на практике оказалось 2048 = 2^11 !!!
      
      uart_puts("Tick/Angle = 0x");         // вывод надписи Tick/Angle = 0x
      uart_puthex_byte(tock.du_c[1]);       // вывод старших 4 бит данных от AS5045
      uart_puthex_byte(tock.du_c[0]);       // вывод следующих 8 бит данных от AS5045
      uart_puts("/");
      
      // преобразование тиков в значение угола наклона:
      angle.du_l = (unsigned int)(0.879*tock.du_l);// значение угла целое с десятыми долями   
      
      uart_puti(angle.du_l);                // вывод значения угла поворота
      uart_puts("`; ");                     // вывод знаков `; 
           
      // контроль правильности данных D9...D0:
      valid.du_l = tick.du_l&0x7ff;         // маскирование --> '0000 0000 0000 0clm mp-- ----'
      valid.du_l /= 1024;                   // 1024 = 2^10 --> '0000 0000 0000 0000 0000 000c'
      
      if (valid.du_l == 0)                  // c = 0
        uart_puts("valid data; ");          // вывод надписи 'valid data; '
      else
      if (valid.du_l == 1)                  // c = 1
        uart_puts("invalid data; ");        // вывод надписи 'invalid data; '
      
      // индикатор диапазона силы магнитного поля:
      range.du_l = tick.du_l&0x3ff;         // маскирование --> '0000 0000 0000 00lm mp-- ----'
      range.du_l /= 128;                    // 128 = 2^7 --> '0000 0000 0000 0000 0000 0lmm' 
      
      if (range.du_l == 0)                  // lmm = 000
        uart_puts("GREEN range");           // вывод надписи 'GREEN range'
      else
      if (range.du_l == 3)                  // lmm = 011
        uart_puts("YELLOW range");          // вывод надписи 'YELLOW range'
      else
      if (range.du_l == 7)                  // lmm = 111
        uart_puts("RED range");             // вывод надписи 'RED range'
      else
        uart_puts("outside of range");      // вывод надписи 'outside of range'
      
      uart_putc(0x0d);                      // возврат каретки
      uart_putc(0x0a);                      // перевод на следующую строку
      
      LED_TOGGLE;                           // светодиод меняет состояние на противоположное
      CS_SET;                               // деактивация ведомого, завершение чтения данных

      __watchdog_reset();                   // "простой" cброс сторожевого таймера
      
    } // end of 'for (;;)' 
  } // end of 'if (!fl_set)' 
///////////////////////// Работа в режиме -= ДАТЧИК =- /////////////////////////
  else
  {
    // инициализация USART (2400):
    UCSR0B = 0x00;                          // запрет настроек USART на время установки скорости передачи
    UCSR0A = 0x00;                          
    UCSR0C = 0x06;                          // размер слова данных 8 бит
    UBRR0L = UBBR_2K4L;                     // задание скорости 2400
    UBRR0H = UBBR_2K4H;   
    UCSR0B = 0x0C;                          // разрешение передачи (TXENn = 1); 9-Bit

    // инициализация Т/С0:
    TCCR0B = 0x00;                          // останов Т/С0
    TCNT0  = RELOAD_TIM0;                   // нач. знач-е
    TCCR0A = 0x00;
    TCCR0B = START_TIM0;                    // таймер запускаем
    TIMSK0 = 0x01;                          // Т/С0 <- источник прерываний
    
    SPI_MasterInit();                       // инициализация SPI в режиме Master
    
    __enable_interrupt();                   // прерывания разрешаем   
////////////////////////////////////////////////////////////////////////////////  
          
                    //Организация работы линии обмена K-LINE                    
          
////////////////////////////////////////////////////////////////////////////////      
    for (;;)
    {
      UCSR0B &= ~(1<<RXEN0);                // отключение приемника USART
      count_bod = CBOD;                     // счетчик БОД

      do
      {
        if (!(PIND & (1<<RXD))) count_bod = CBOD;
      } while (count_bod);                  // ожидание СИНХРО-ПАУЗЫ (всегда только перед командой)

      UCSR0B |= (1<<RXEN0);                 // включение приемника USART

      while (!(UCSR0A & (1<<RXC0)));        // ждем завершение приема байта 

      if (UCSR0B & (1<<RXB80))              // если 9-й бит =1, то принята команда
      {
        unsigned char var;
        var  = UDR0;                        // UDRn - USART I/O Data Register n
        var &= 0x0f;                        // адрес датчика д/б не более 15
        if (var == NDEV)                    // обратились к этому датчику?
        {    
          t_led_on  = T_LED_ON;             // время подсвечивания
          LED_ON;                           // LED-ON
                   
          CS_RES;                           // активация ведомого, инициализация чтения данных 

          SPI_WriteRead(0);                 // чтение старших 8 бит данных от AS5045
          tick.du_c[2] = SPDR;              // байт данных от AS5045 --> 'dddd dddd'
      
          SPI_WriteRead(0);                 // чтение следующих 8 бит данных от AS5045
          tick.du_c[1] = SPDR;              // байт данных от AS5045 --> 'dddd oclm'
      
          SPI_WriteRead(0);                 // чтение следующих 8 бит данных от AS5045
          tick.du_c[0] = SPDR;              // байт данных от AS5045 --> 'mp-- ----'
/*      
          Делением на 4096 = 2^12 число 'dddd dddd dddd oclm mp-- ----' 
          приводится к 12-и битовому формату '0000 0000 0000 dddd dddd dddd', 
          которое содержит только угловые данные:
*/      
          tock.du_l = tick.du_l/2048;       // на практике оказалось 2048 = 2^11 !!!
      
          // преобразование тиков в значение угола наклона:
          angle.du_l = (unsigned int)(0.879*tock.du_l);// значение угла целое с десятыми долями 
          
          uart_putc(angle.du_c[1]);         // вывод угла на БЦК или SMON
          uart_putc(angle.du_c[0]); 
     
          CS_SET;                           // деактивация ведомого, завершение чтения данных
         
          __watchdog_reset();               // cброс сторожевого таймера
          
        } // end of 'if (var == NDEV)' 
      } // end of 'if (UCSR0B & (1<<RXB80))' 
    } // end of 'for (;;)' 
  } // end of 'else' 
} // end of 'main' 
/*==============================================================================*/
/*                                                                              */
/*                                Подпрограммы.                                 */
/*                                                                              */
/*==============================================================================*/

#pragma vector=TIMER0_OVF_vect
__interrupt void timer0_ovf_isr(void)
{
  //TIMER0 has overflowed
  TCNT0  = RELOAD_TIM0;                    // reload counter value

  if (count_bod)  count_bod--;

  if(t_led_on)  t_led_on--;                // время подсвечивания --
  else          LED_OFF;                   // LED-OFF
}

// Подпрограмма инициализации SPI в режиме Master
void SPI_MasterInit(void)
{
/* - Разрешение SPI в режиме мастера,
   - CPOL = 1 — генерируются тактовые импульсы отрицательной полярности,
   - CPHA = 1 — обработка данных производится по переднему фронту импульсов сигнала SCK,
   - установка скорости обмена fck/128 */
  SPCR = (1<<SPE)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(1<<SPR1)|(1<<SPR0);
}

// Подпрограмма записи/чтения через SPI
unsigned char SPI_WriteRead(unsigned char dataout)
{
  // Запись байта в регист данных ведущего (инициализация передачи)
  SPDR = dataout;
  // Ожидание завершения передачи (пока бит SPIF не установлен)
  while(!(SPSR & (1<<SPIF)));
  // Чтение принятых данных и выход из процедуры
  return SPDR;
}
