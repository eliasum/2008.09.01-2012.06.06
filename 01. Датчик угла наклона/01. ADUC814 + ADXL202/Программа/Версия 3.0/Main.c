/********************************************************************************/
/*                                                                              */
/*                       ”правл€юща€ программа дл€ 'ADXL202'                    */
/*                          ¬ерси€ 3.0 (27 июл€ 2009 г)                         */
/*                                                                              */
/********************************************************************************/
#include "main.h"

// коэффициент усреднени€
#define NSUM 25

/*==============================================================================*/
/*                                ќписание типов                                */
/*==============================================================================*/
union u_int                                 // дл€ 2-х байтовых данных
  {
   unsigned int  du_i;                      // data_union_int
   unsigned char du_c[2];                   // data_union_char
  };                                        // 256*[0] + [1]

idata struct MEASURE {                      // описание структуры 1-го замера
  union u_int T1X;
  union u_int T2X;
  union u_int T1Y;
  union u_int T2Y;  };
/*==============================================================================*/
/*                      √лобальные переменные программы.                        */
/*==============================================================================*/
idata struct MEASURE Buff[NSUM];           // очередь замеров
data struct MEASURE one;                   // 1-н замер
data struct MEASURE Z;                     // 1-н ”—–≈ƒЌ≈ЌЌџ… замер

unsigned long s1, s2, s3, s4;              // 0..0x0ffffffff
unsigned char i;                           // 0..0x0ff
unsigned char get_one;                     // номер замера
unsigned int n1, n2, n3, n4;

/*==============================================================================*/
/*                                                                              */
/*                         √лавна€ функци€ программы.                           */
/*                                                                              */
/*==============================================================================*/
void main(void)
{
  IE = 0;                                  // все прерывани€ запрещены

// настройка синтезатора
  PLLCON = 0x001;                          // синтезатор рабочей частоты €дра
                                           // Core Clk = XTALL*256 = 32768*256 = 8388608 герц
// настройка сторожевого таймера
  WDWR = 1;                                // разрешение записи в 'WDCON'
  WDCON = 0x072;                           // запуск WDT с временным интервалом 2с

// настройка UART:
  SCON = 0x040;                            // настройка последовательного порта на 
                                           // асинхронный 8-битовый режим
// настройка “/—0:
  TMOD = 0x001;                            // T/C0 - таймер

// настройка “/—2:
  RCAP2H = 0x0FF;                          // задание скорости 9600 бод 
  RCAP2L = 0x0E5;                          // (814code_asm)
  TH2    = 0x0FF;       
  TL2    = 0x0E5; 
  T2CON  = 0x030;                          // установка “/—2 в качестве генератора скорости UART
  TR2    = 1;                              // запуск генератора скорости 'UART'

  s1=0; n1=0;
  s2=0; n2=0;
  s3=0; n3=0;
  s4=0; n4=0;
 
  for (i=0; i<25; i++) {Buff[i].T1X.du_i=0; 
                        Buff[i].T2X.du_i=0; 
						Buff[i].T1Y.du_i=0; 
						Buff[i].T2Y.du_i=0;}
  for(;;)
  {
    meas_xy();                             // получаем один замер

//  расчет "скольз€щего среднего":
                                           
	s1 -= Buff[n1].T1X.du_i;
	s1 += one.T1X.du_i;
	Buff[n1].T1X.du_i=one.T1X.du_i;
	n1++;
	if (n1==NSUM) n1=0;
	Z.T1X.du_i=s1/NSUM;

	s2 -= Buff[n2].T2X.du_i;
	s2 += one.T2X.du_i;
	Buff[n2].T2X.du_i=one.T2X.du_i;
	n2++;
	if (n2==NSUM) n2=0;
	Z.T2X.du_i=s2/NSUM;

	s3 -= Buff[n3].T1Y.du_i;
	s3 += one.T1Y.du_i;
	Buff[n3].T1Y.du_i=one.T1Y.du_i;
	n3++;
	if (n3==NSUM) n3=0;
	Z.T1Y.du_i=s3/NSUM;

	s4 -= Buff[n4].T2Y.du_i;
	s4 += one.T2Y.du_i;
	Buff[n4].T2Y.du_i=one.T2Y.du_i;
	n4++;
	if (n4==NSUM) n4=0;
	Z.T2Y.du_i=s4/NSUM;	  

    Tx_means();                           // выводим "среднее" в 'UART'

// сброс сторожевого таймера
    EA   = 0;
    WDWR = 1;
    WDE  = 1;
    EA   = 1;
  }
}

void meas_xy(void)
{
// измерение длительности и периода импульсов с выхода 'Xout' -------= X =--------

  TH0 = 0; TL0 = 0;                        // сброс 'T0'
  while(XOUT);                             // корректировка расчета длительности импульсов с выхода 'Xout'
  while(!XOUT);                            // ожидание фронта 1-го импульса с выхода 'Xout'
  TR0 = 1;                                 // запуск 'T0'

  while(XOUT);                             // ожидание спада 1-го импульса с выхода 'Xout'
  TR0 = 0;                                 // останов 'T0'
  one.T1X.du_c[0] = TH0;
  one.T1X.du_c[1] = TL0;                   // -= ƒЋ»“≈Ћ№Ќќ—“№ »ћѕ”Ћ№—ј 'X' =-    *
  TH0 = 0; TL0 = 0;                        // сброс 'T0'

  while(XOUT);                             // корректировка расчета периода импульсов с выхода 'Xout'
  while(!XOUT);                            // ожидание фронта 2-го импульса с выхода 'Xout'
  TR0 = 1;                                 // запуск 'T0'

  while(XOUT);                             // ожидание спада 2-го импульса с выхода 'Xout'
  while(!XOUT);                            // ожидание фронта 3-го импульса с выхода 'Xout'
  TR0 = 0;                                 // останов 'T0'
  one.T2X.du_c[0] = TH0;
  one.T2X.du_c[1] = TL0;                   // -= ѕ≈–»ќƒ »ћѕ”Ћ№—ј 'X' =-          *

// измерение длительности и периода импульсов с выхода 'Yout' -------= 'Y' =------

  TH0 = 0; TL0 = 0;                        // сброс 'T0'
  while(YOUT);                             // корректировка расчета длительности импульсов с выхода 'Yout'
  while(!YOUT);                            // ожидание фронта 1-го импульса с выхода 'Yout'
  TR0 = 1;                                 // запуск 'T0'

  while(YOUT);                             // ожидание спада 1-го импульса с выхода 'Yout'
  TR0 = 0;                                 // останов 'T0'
  one.T1Y.du_c[0] = TH0;
  one.T1Y.du_c[1] = TL0;                   // -= ƒЋ»“≈Ћ№Ќќ—“№ »ћѕ”Ћ№—ј 'Y' =-    *
  TH0 = 0; TL0 = 0;                        // сброс 'T0'

  while(YOUT);                             // корректировка расчета периода импульсов с выхода 'Yout'
  while(!YOUT);                            // ожидание фронта 2-го импульса с выхода 'Yout'
  TR0 = 1;                                 // запуск 'T0'

  while(YOUT);                             // ожидание спада 2-го импульса с выхода 'Yout'
  while(!YOUT);                            // ожидание фронта 3-го импульса с выхода 'Yout'
  TR0 = 0;                                 // останов 'T0'
  one.T2Y.du_c[0] = TH0;
  one.T2Y.du_c[1] = TL0;                   // -= ѕ≈–»ќƒ »ћѕ”Ћ№—ј 'Y' =-          *
  TH0 = 0; TL0 = 0;                        // сброс 'T0'
}

void Tx_means(void)
{                                          // из пам€ти побайтно
  unsigned char d, cc;                     // и выводим в 'UART'

  cc = 0x05a;
  Tx_byte(cc);

  d = Z.T1X.du_c[1]; cc += d; Tx_byte(d);
  d = Z.T1X.du_c[0]; cc += d; Tx_byte(d);
  d = Z.T2X.du_c[1]; cc += d; Tx_byte(d);
  d = Z.T2X.du_c[0]; cc += d; Tx_byte(d);

  d = Z.T1Y.du_c[1]; cc += d; Tx_byte(d);
  d = Z.T1Y.du_c[0]; cc += d; Tx_byte(d);
  d = Z.T2Y.du_c[1]; cc += d; Tx_byte(d);
  d = Z.T2Y.du_c[0]; cc += d; Tx_byte(d);

  Tx_byte(cc);
}

void Tx_byte(char outbyte)                 // вывод байта в 'UART'
{
  SBUF = outbyte;
  while (!TI);
  TI = 0;
}