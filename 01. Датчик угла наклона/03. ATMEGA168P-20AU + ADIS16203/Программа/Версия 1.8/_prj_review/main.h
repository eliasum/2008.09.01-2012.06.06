#ifndef _main_h_
#define _main_h_

#include "common.h"
#include "terminal.h"
#include "variable.h"

#define BR9K6        9600                  // скорость обмена 9600
#define UBBR_9K6     ((F_CPU/(16L*BR9K6))-1)

#define CBR2K4       (unsigned int) ((F_CPU/(16L*2400))-1)
#define UBBR_2K4L    (unsigned char)(CBR2K4&0x0FF)
#define UBBR_2K4H    (unsigned char)((CBR2K4>>8)&0x0FF)

#define SYSTEM_TICK  600                   // частота переполнения таймера в Гц
#define START_TIM0   0x04                  // предварительный делитель F_CPU/256
#define RELOAD_TIM0  0xB8                  // константа перезагрузки 'TIM0'
/*
Частота переполнения таймера = 600 Гц.
Однобайтный таймер-счеткик переполняется через 256 (0xFF) тактов генератора.
Для генератора F_CPU/256 = 43200 Гц возникает с частотой (43200 Гц / 256) = 168,75 Гц.
Для переполнения с частотой 600 Гц небходимо 43200 Гц / 600 = 72 такта генератора.
Таймер-счетчик толжен начинать счет с 256 - 72 = 184 = 0xB8
*/
#define CBOD         4                     // константа БОД
#define NDEV         4                     // базовый адрес устройства
#define T_LED_ON     (SYSTEM_TICK/5)       // время индикации обращения к датчику

#define TEMP_OUT     0x0A                  // регистр температурных данных
#define INCL_OUT     0x0C                  // регистр угловых данных
#define INCL_180_OUT 0x0E                  // регистр угловых данных ±180°
#define AVG_CNT      0x38                  // регистр управления усреднением данных
#define SMPL_TIME    0x36                  // регистр управления периодом выборок
/*==============================================================================*/
/*                              Аппаратные особенности                          */
/*==============================================================================*/
// определения выводов порта B
#define LED          PORTB0                // вывод управления сетодиодным индикатором     OUT (1)
#define CS           PORTB2                // вывод управления запуском "ведомого" SPI     OUT (1)
#define MOSI         PORTB3                // вывод передачи данных "ведущим" по SPI       OUT (1)
#define MISO         PINB4                 // вывод приема данных "ведущим" по SPI         IN  (^)
#define SCK          PORTB5                // вывод тактового сигнала от "ведущего" SPI    OUT (0)

#define LED_ON       PORTB &= ~(1<<LED)
#define LED_OFF      PORTB |=  (1<<LED)
#define CS_SET       PORTB |=  (1<<CS)
#define CS_RES       PORTB &= ~(1<<CS)
#define LED_TOGGLE   cpl(PORTB, LED)

// определения выводов порта D
#define RXD   PIND0                        // вывод приема данных через COM-порт           IN  (^)
#define TXD   PORTD1                       // вывод передачи данных через COM-порт         OUT (1)
#define NAGR  PORTD4                       // вывод управления нагревательным элементом    OUT (0)
#define SET_  PIND5                        // вывод конфигурации режима работы             IN  (^)
#define KLINE PORTD6                       // вывод управления разрешения чипа 'K-LINE'    OUT (1)
                                           // "разрешение приема = 1"
#define RST   PORTB7                       // вывод управления сбросом "ведомого"          OUT (1)
                                            
#define NAGR_ON      PORTD |=  (1<<NAGR)
#define NAGR_OFF     PORTD &= ~(1<<NAGR)
#define RST_ENABLE   PORTD &= ~(1<<RST)
#define RST_DISABLE  PORTD |=  (1<<RST)
/*
  обозначения:
  - IN  (^) - вывод входа(чтение), ^ - резистивная подтяжка;
  - OUT (0) - вывод выхода(запись) начальное состояние 0, активное состояние 1;
  - OUT (1) - вывод выхода(запись) начальное состояние 1, активное состояние 0;
  Начальное и активное состояние выводов OUT определяется по принцип. схеме.

  Разряд DDxn регистра DDx определяет направление передачи данных
  через контакт ввода/вывода. Если этот разряд установлен в «1», то n-й вывод
  порта является выходом, если же сброшен в «0» — входом.
  Разряд PORTxn регистра PORTx выполняет двойную функцию. Если
  вывод функционирует как выход (DDxn = «1»), этот разряд определяет состояние 
  вывода порта. Если разряд установлен в «1», на выводе устанавливается 
  напряжение ВЫСОКОГО уровня. Если разряд сброшен в «0», на выводе 
  устанавливается напряжение НИЗКОГО уровня. Если же вывод функционирует как 
  вход (DDxn = «0»), разряд PORTxn определяет состояние внутреннего 
  подтягивающего резистора для данного вывода. При установке разряда PORTxn в «1»
  подтягивающий резистор подключается между выводом микроконтроллера 
  и проводом питания.
  Состояние вывода микроконтроллера (независимо от установок разряда DDxn) 
  может быть получено путем чтения разряда PINxn регистра PINx.
*/
/*==============================================================================*/
/*                                Описание типов                                */
/*==============================================================================*/
union u_int                                // для 2-х байтовых данных без знака
  {
    unsigned int  du_i;                    // data_union_int
    unsigned char du_c[2];                 // data_union_char
  };                                       // 256*[0] + [1]

union u_sint                               // для 2-х байтовых данных со знаком
  {
    signed int  du_si;                     // data_union_int
    signed char du_sc[2];                  // data_union_char
  };                                       // 256*[0] + [1]

/*==============================================================================*/
/*                                Прототипы                                     */
/*==============================================================================*/
void SPI_MasterInit(void);
unsigned char SPI_WriteRead(unsigned char dataout);
unsigned int moving_average(unsigned int znachenie);
void termostat(signed int temperatura, unsigned char t0); 
void get_sens(void);
void avg_cnt(void);
void smpl_time(void);
#endif
