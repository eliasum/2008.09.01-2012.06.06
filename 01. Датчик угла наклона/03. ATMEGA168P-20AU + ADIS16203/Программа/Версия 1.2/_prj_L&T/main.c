/********************************************************************************/
/*                                                                              */
/*             Управляющая программа для 'ATMEGA168P' + 'ADIS16203'             */
/*                         Версия 1.2 (13 июля 2010 г)                          */
/*                                                                              */
/********************************************************************************/
#include "main.h"
#include <math.h>

/*==============================================================================*/
/*                      Глобальные переменные программы.                        */
/*==============================================================================*/

union u_int angle, tick;
union u_sint angle_180, tick_180;
union u_sint temp, tock;

unsigned char const __flash Title[] = "ADIS16203 - convertion Tick to Angle";
                                            
unsigned char Ttick;                        // градусы по Цельсию "целые"
signed int t0;

volatile unsigned char rr_cnt;              // интервал до перезапуска 'WDT'
volatile unsigned char rr_flg;              // флаг перезапуска 'WDT'
volatile unsigned char count_bod;           // счетчик БОД

unsigned char fl_set;                       // признак установки режима работы

unsigned char var;                          // врем. хран-е данных

volatile unsigned int to_mc;                // 10 сек

/*==============================================================================*/
/*                                                                              */
/*                         Главная функция программы.                           */
/*                                                                              */
/*==============================================================================*/
int main(void)
{
/*  
  Разряд DDxn регистра DDx определяет направление передачи данных
через контакт ввода/вывода. Если этот разряд установлен в «1», то n-й вывод
порта является выходом, если же сброшен в «0» — входом.
  Разряд PORTxn регистра PORTx выполняет двойную функцию. Если
вывод функционирует как выход (DDxn = «1»), этот разряд определяет состояние 
вывода порта. Если разряд установлен в «1», на выводе устанавливается 
напряжение ВЫСОКОГО уровня. Если разряд сброшен в «0», на выводе 
устанавливается напряжение НИЗКОГО уровня. Если же вывод функционирует как 
вход (DDxn = «0»), разряд PORTxn определяет состояние внутреннего 
подтягивающего резистора для данного вывода. При установке разряда PORTxn в «1»
подтягивающий резистор подключается между выводом микроконтроллера 
и проводом питания.
  Состояние вывода микроконтроллера (независимо от установок разряда DDxn) 
 может быть получено путем чтения разряда PINxn регистра PINx.
*/
  PORTD = (1<<RXD)|(1<<TXD)|(1<<STR)|(1<<SET_)|(1<<KLINE)|(1<<RST);
  DDRD  = (1<<TXD)|(1<<STR)|(1<<KLINE)|(1<<RST);
   
  PORTB = (1<<LED)|(1<<CS)|(1<<MOSI)|(1<<MISO);
  DDRB  = (1<<LED)|(1<<DIR)|(1<<CS)|(1<<MOSI)|(1<<SCK);
  
  #define PRT_RXD PIND

  if (PIND & (1<<SET_)) fl_set = 1; else fl_set = 0; // выбор режима работы датчика

  // TIMER0 initialize - prescale:256
  // WGM:           Normal
  // desired value: 600Hz
  // actual value:  600.000Hz (0.0%)

  TCCR0B = 0x00;                            // останов Т/С0
  TCNT0  = 0xB8;                            // нач. знач-е
  TCCR0A = 0x00;
  TCCR0B = 0x04;                            // таймер запускаем
  TIMSK0 = 0x01;                            // Т/С0 <- источник прерываний

  rr_flg  = 0;                              // только "простой" сторожевой таймер
  to_mc   = TO_CEL_SET;                     // интервал опроса темп-ры
  count_bod = 1;                            // минимум 1 прерывание
  
  cpl(PORTD, STR);                          // 1-й "простой" cброс сторожевого таймера
  
  __enable_interrupt();                     // прерывания разрешаем

//////////// Работа в режиме -= УСТАНОВКИ =- /////////////////////////////////
  if (!fl_set)
  {
    // инициализация USART (9600):
    UCSR0B = 0x00;                          // UCSRnB – USART Control and Status Register n B
    UCSR0A = 0x00;                          // UCSRnA – USART Control and Status Register n A
    // ^=> запрет на время установки скорости передачи настроек USART0

    UCSR0C = 0x06;                          // UCSRnC – USART Control and Status Register n C *1)
    // ^=> размер слова данных 8 бит
    UBRR0L = (unsigned char)UBBR_9K6;       // задание скорости 9600; пример в datasheet
    UBRR0H = (unsigned char)(UBBR_9K6>>8);
    UCSR0B = 0x08;                          // разрешение передачи *2)
    
    PORTD &= ~(1<<RST);                     // сброс ведомого импульсом длительностью 100 мкс
    delay_us(100);
    PORTD |= (1<<RST);   
    SPI_MasterInit();                       // инициализация SPI в режиме Master
    
    // вывод строки из ПЗУ, uart_putc(0x0a); - перевод на след. строку  
    uart_puts_p(Title);                                 uart_putc(0x0d); uart_putc(0x0a);                        
    uart_puts("------------------------------------");  uart_putc(0x0d); uart_putc(0x0a);  
     
    for (;;)
    {      
      while(count_bod);                     // ждать как
      count_bod = 1;                        // минимум 1 прерывание 
      
      unsigned char byte;
      
      PORTB &= ~(1<<CS);                    // активация ведомого
////////////////////////////////////////////////////////////////////////////////  
          
                          //ВЫВОД УГЛА 360° (INCL_OUT)
          
////////////////////////////////////////////////////////////////////////////////        
      byte = INCL_180_OUT;                  // адрес регистра, вывод из которого в последующем цикле    
      SPI_WriteRead(byte);                  // запрос на чтение старшего байта регистра INCL_180_OUT
      tick.du_c[1] = SPDR;                  // старший байт данных из INCL_OUT  
      tick.du_c[1] &= 0x3f;                 // данные 14 бит
      
      byte = 0x0C;                          // любые данные
      SPI_WriteRead(byte);                  // запрос на чтение младшего байта регистра INCL_180_OUT
      tick.du_c[0] = SPDR;                  // младший байт данных из INCL_OUT 
       
      uart_puts("Tick/Angle = 0x");         // вывод надписи Tick/Angle = 0x
      uart_puthex_byte(tick.du_c[1]);       // вывод старшего байта данных из INCL_OUT
      uart_puthex_byte(tick.du_c[0]);       // вывод младшего байта данных из INCL_OUT
      uart_puts("/");                       // вывод знака / 
      
      // преобразование тиков в значение угола наклона:
      angle.du_i = (unsigned int)(0.25*tick.du_i);
      
      uart_puti(angle.du_i);                // вывод значения угла наклона с десятичным значением без запятой
      uart_puts("`;");                      // вывод знаков `;  
      uart_putc(0x0d);                      // возврат каретки
      uart_putc(0x0a);                      // перевод на следующую строку 
                     
////////////////////////////////////////////////////////////////////////////////  
          
                        //ВЫВОД УГЛА ±180° (INCL_180_OUT)
          
////////////////////////////////////////////////////////////////////////////////        
      byte = TEMP_OUT;                      // адрес регистра, вывод из которого в последующем цикле    
      SPI_WriteRead(byte);                  // запрос на чтение старшего байта регистра TEMP_OUT
      tick_180.du_sc[1] = SPDR;             // старший байт данных из INCL_180_OUT  
      tick_180.du_sc[1] &= 0x3F;            // данные 14 бит
      
      byte = 0x0E;                          // любые данные
      SPI_WriteRead(byte);                  // запрос на чтение младшего байта регистра TEMP_OUT
      tick_180.du_sc[0] = SPDR;             // младший байт данных из INCL_180_OUT 
/*
      Учет знака числа. Сдвиг влево на два бита - "дополнение" числа до стандартного 
      формата 16 бит, в котором 16-й бит содержит информацию о знаке числа:
*/
      tick_180.du_si = tick_180.du_si << 2; 
/*
      Делением на 4 число "приводится обратно" к исходному 14-и битовому формату 
      с сохранением функции старшего бита числа как знакового:
*/ 
      tick_180.du_si /= 4; 
      
      uart_puts("Tick_180/Angle_180 = 0x"); // вывод надписи Tick_180/Angle_180 = 0x
      uart_puthex_byte(tick_180.du_sc[1]);  // вывод старшего байта данных из INCL_180_OUT
      uart_puthex_byte(tick_180.du_sc[0]);  // вывод младшего байта данных из INCL_180_OUT
      uart_puts("/");                       // вывод знака / 
      
      // преобразование тиков в значение угола наклона:
      angle_180.du_si = (signed int)(0.025*tick_180.du_si);     
      
      uart_puti(angle_180.du_si);           // вывод значения угла наклона  
      uart_puts("`;");                      // вывод знаков `;   
      uart_putc(0x0d);                      // возврат каретки
      uart_putc(0x0a);                      // перевод на следующую строку 
////////////////////////////////////////////////////////////////////////////////  
          
                          //ВЫВОД ТЕМПЕРАТУРЫ (TEMP_OUT)
          
////////////////////////////////////////////////////////////////////////////////        
      byte = INCL_OUT;                      // адрес регистра, вывод из которого в последующем цикле      
      SPI_WriteRead(byte);                  // запрос на чтение старшего байта регистра INCL_OUT
      tock.du_sc[1] = SPDR;                 // старший байт данных из TEMP_OUT
      tock.du_sc[1] &= 0x0F;                // данные 12 бит
 
      byte = 0x0A;                          // любые данные
      SPI_WriteRead(byte);                  // запрос на чтение младшего байта регистра INCL_OUT
      tock.du_sc[0] = SPDR;                 // младший байт данных из TEMP_OUT 
/*
      Учет знака числа. Сдвиг влево на 4 бита - "дополнение" числа до стандартного 
      формата 16 бит, в котором 16-й бит содержит информацию о знаке числа:
*/
      tock.du_si = tock.du_si << 4; 
/*
      Делением на 16 число "приводится обратно" к исходному 12-и битовому формату 
      с сохранением функции старшего бита числа как знакового:
*/
      tock.du_si /= 16;
      
      uart_puts("Tock/Temperature = 0x");   // вывод надписи Tock/Temperature = 0x
      uart_puthex_byte(tock.du_sc[1]);      // вывод старшего байта данных из TEMP_OUT
      uart_puthex_byte(tock.du_sc[0]);      // вывод младшего байта данных из TEMP_OUT
      uart_puts("/");                       // вывод знака / 
      
      // преобразование тиков в значение температуры:
      float delta;
      if (tock.du_si >= 0x04FE)
      {
        delta = tock.du_si - 0x04FE;
        temp.du_si = (signed int)(25 - 0.47*delta);
      }  
      else
      {
        delta = 0x04FE - tock.du_si;
        temp.du_si = (signed int)(25 + 0.47*delta);
      }         
            
      uart_puti(temp.du_si);                // вывод значения температуры
      uart_puts("`C ");                     // вывод знаков `C
      
      uart_putc(0x0d);                      // возврат каретки
      uart_putc(0x0a);                      // перевод на следующую строку 
      delay_ms(250);                        // задержка для усреднения показаний
           
      PORTB |= (1<<CS);                     // деактивация ведомого

      cpl(PORTD, STR);                      // "простой" cброс сторожевого таймера
    }
  }
    
//////////// Работа в режиме -= ДАТЧИК =- ////////////////////////////////////
  else
  {
    // инициализация USART (2400)
    UCSR0B = 0x00;                          // запрет на время установки скорости
    UCSR0A = 0x00;                          // передачи настроек USART
    UCSR0C = 0x06;                          // размер слова данных 8 бит
    UBRR0L = (unsigned char)UBBR_2K4;       // задание скорости 2400; пример в datasheet
    UBRR0H = (unsigned char)(UBBR_2K4>>8);
    UCSR0B = 0x0C;     
   
    meas_xy();
    Meas_Cel();

    rr_cnt = RR_CONST;                      // установки сторожевого таймера
    rr_flg = 0x0f;                          // + 16*0.25=4 сек
    cpl(PORTD, STR);                        // cброс сторожевого таймера

    for (;;)
    {
      UCSR0B &= ~(1<<RXEN0);                // прием по 'RxD' 'OFF'
      count_bod = CBOD;                     // счетчик БОД

      do {
        if (!(PRT_RXD & (1<<RXD))) count_bod = CBOD;
      } while (count_bod);                  // ожидание СИНХРО-ПАУЗЫ

      UCSR0B |= (1<<RXEN0);                 // прием по 'RxD' 'ON'
      while (UCSR0A & (1<<RXC0))
        var = UDR0;                         // "чистим" приемный буфер

      while (!(UCSR0A & (1<<RXC0)));        // "ждем" байт

      if (UCSR0B & (1<<RXB80))
      {
        var  = UDR0;
        var &= 0x0f;
        if (var == NDEV)                    // обратились к этому датчику?
        {
          /*float Lind;
          int   rvrs_type;
          union u_int Ugol;*/

          cpl(PORTB, LED);                 // LED-TOGGLE светодиод меняет состояние на противоположное.
////////////////////////////////////////////////////////////////////////////////  
          
          //функция преобразования кода в угол
          
////////////////////////////////////////////////////////////////////////////////  
          
          //termostat();                   
          
////////////////////////////////////////////////////////////////////////////////          
          /*rvrs_type = (int)(0.5 + Lind);
          if(rvrs_type < 0)
          {
            Ugol.du_i = 65536 - rvrs_type;
            Ugol.du_c[1] |= 0x80;
          }
          else
            Ugol.du_i = rvrs_type;
          uart_putc(Ugol.du_c[0]);
          uart_putc(Ugol.du_c[1]);*/
        ////////////////////////////////////////////////////////////////////////
          
        }
        meas_xy();                          // в люб. случае обновляем замер
        Meas_Cel();
        rr_flg = 0x0f;                      // + 16*0.25=4 сек
        cpl(PORTD, STR);                    // cброс сторожевого таймера
      }
    }
  }
////////////////////////////////////////////////////////////////////////////////
}

void meas_xy(void)
{
  unsigned char sreg = SREG;
  __disable_interrupt();                   //disable all interrupts

////////////////////////////////////////////////////////////////////////////////  
          
          //преобразование кода в угол
          
//////////////////////////////////////////////////////////////////////////////// 
  
  SREG = sreg;                             // разрешить прерывания (если они были установлены)
}

void Meas_Cel(void)
{
  if(to_mc > (TO_CEL_SET-1))
  {
    unsigned char sreg = SREG;
    __disable_interrupt();                 //disable all interrupts

////////////////////////////////////////////////////////////////////////////////  
          
          //получение значения температуры
          
////////////////////////////////////////////////////////////////////////////////     
    
    to_mc = 0;
    SREG = sreg;                           // разрешить прерывания
  }
}

/*==============================================================================*/
/*                                                                              */
/*                                Подпрограммы.                                 */
/*                                                                              */
/*==============================================================================*/

/*void termostat(void)                       // Алгоритм термостатирования
{
   if(Ttick <= t0)		                          
   PORTD |= (1<<NAGR);
    
   else
     {  
        if(Ttick > t0)	
        PORTD &= ~(1<<NAGR);  
     }
}*/

#pragma vector=TIMER0_OVF_vect
__interrupt void timer0_ovf_isr(void)
{
  //TIMER0 has overflowed
  TCNT0  = CONST_RELOAD;       // reload counter value

  if (count_bod)  count_bod--;

  if (rr_flg & 0x0f)
  {
    if (rr_cnt) rr_cnt--;
    else
    {
      rr_flg--;
      rr_cnt = RR_CONST;
      cpl(PORTD, STR);
    }
  }
  if(to_mc < TO_CEL_SET) to_mc++;
}

// Подпрограмма инициализации SPI в режиме Master
void SPI_MasterInit(void)
{
/* - Разрешение SPI в режиме мастера,
   - CPOL = 1 - генерируются тактовые импульсы отрицательной полярности,
   - CPHA = 1 - — обработка данных производится по заднему фронту импульсов сигнала SCK,
   - установка скорости обмена fck/128 */
  SPCR = (1<<SPE)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|(1<<SPR1)|(1<<SPR0);
}

// Подпрограмма записи/чтения через SPI
unsigned char SPI_WriteRead(unsigned char dataout)
{
  // Запись байта в регист данных ведущего (инициализация передачи)
  SPDR = dataout;
  // Ожидание завершения передачи (пока бит SPIF не установлен)
  while(!(SPSR & (1<<SPIF)));
  // Чтение принятых данных и выход из процедуры
  return SPDR;
}

/* *1)
Bit    7         6        5       4       3       2        1        0
    UMSELn1 | UMSELn0 | UPMn1 | UPMn0 | USBSn | UCSZn1 | UCSZn0 | UCPOLn | UCSRnC
       0    |    0    |       |       |       |        |        |        | Asynchronous USART
            |         |   0   |   0   |       |        |        |        | Parity Mode disabled
            |         |       |       |   0   |        |        |        | Stop Bit(s) - 1-bit
            |         |       |       |       |   1    |   1    |        | Character Size - 8-bit
            |         |       |       |       |        |        |   0    | zero when asynchronous mode is used
размер слова данных 8 бит => 0b00000110 = 0x06
   *2)
Bit    7         6        5       4       3       2        1       0
     RXCIEn | TXCIEn | UDRIEn | RXENn | TXENn | UCSZn2 | RXB8n | TXB8n | UCSRnB
       0    |        |        |       |       |        |       |       | RX Complete Interrupt Enable n
            |    0   |        |       |       |        |       |       | TX Complete Interrupt Enable n
            |        |    0   |       |       |        |       |       | USART Data Register Empty Interrupt Enable n
            |        |        |   0   |       |        |       |       | Receiver Enable n
            |        |        |       |   1   |        |       |       | Transmitter Enable n
            |        |        |       |       |   0    |       |       | Character Size - 8-bit
            |        |        |       |       |        |   0   |       | Receive Data Bit 8 n
            |        |        |       |       |        |       |   0   | Transmit Data Bit 8 n
разрешение передачи => 0b00001000 = 0x08
*/